<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计组部分期末</title>
      <link href="/2023/01/06/%E6%9C%9F%E6%9C%AB/"/>
      <url>/2023/01/06/%E6%9C%9F%E6%9C%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><hr><h1 id="ISA"><a href="#ISA" class="headerlink" title="ISA"></a>ISA</h1><h2 id="How-to-Improve-the-CPU"><a href="#How-to-Improve-the-CPU" class="headerlink" title="How to Improve the CPU"></a>How to Improve the CPU</h2><ul><li>Reduce the number of instructions<ul><li>Make instructions that do more(CSIC)</li><li>Use better compiler</li></ul></li><li>Use less cycles to perform the instruction<ul><li>Simpler instructions(RISC)</li><li>Use multiple units&#x2F;ALUs&#x2F;cores in parallel</li></ul></li><li>Increase the clock frequency<ul><li>Find a newer technology to manufacture</li><li>Redesign time critical components</li><li>Adopt multi-cycle</li></ul></li></ul><h2 id="ISA-Classification-Basis"><a href="#ISA-Classification-Basis" class="headerlink" title="ISA Classification Basis"></a>ISA Classification Basis</h2><h3 id="ISA-Classes"><a href="#ISA-Classes" class="headerlink" title="ISA Classes"></a>ISA Classes</h3><ul><li>按照CPU<u>内部</u>的存储分类，ISA可以分为三种<ol><li>基于栈（栈结构 | Stack architecture）</li><li>基于累加器（累加器结构 | Accumulator architecture）</li><li>基于寄存器（通用寄存器 | General-purpose register architecture | GPR)</li></ol></li></ul><h3 id="Stack-Architecture"><a href="#Stack-Architecture" class="headerlink" title="Stack Architecture"></a>Stack Architecture</h3><ul><li>Implicit Operands——On the Top of the Stack(TOS)</li><li>First operand removed from second op replaced by the result</li><li>C &#x3D; A + B(memory locations)<ul><li>Push A    </li><li>Push B    </li><li>Add</li><li>Pop C</li></ul></li></ul><center class="half">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061529786.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061550302.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061553982.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061554793.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061555028.png" width="200" height="325"></center><h3 id="Accumulator-Architecture"><a href="#Accumulator-Architecture" class="headerlink" title="Accumulator Architecture"></a>Accumulator Architecture</h3><ul><li><p>One implicit operand: the accumulator</p><p>one explicit operand: mem location</p></li><li><p>Accumulator is both an implicit input operand and a result</p></li><li><p>C &#x3D; A + B</p><p>Load A</p><p>Add B</p><p>Store C</p></li></ul><center class="half">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061600349.png" width="200" height="350">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061601619.png" width="200" height="350">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061601884.png" width="200" height="350">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061601545.png" width="200" height="350"></center><h3 id="GPR-Arthitecture"><a href="#GPR-Arthitecture" class="headerlink" title="GPR Arthitecture"></a>GPR Arthitecture</h3><ul><li><p>Only explicit operands</p><ul><li>registers</li><li>memory locations</li></ul></li><li><p>Operand access:</p><ul><li>direct memory access</li><li>loaded into temporary storage first</li></ul></li><li><p>Two Classes：</p><ul><li><p>Register-memory architecture</p><blockquote><p>any instruction can access memory</p></blockquote></li><li><p>Load-store architecture</p><blockquote><p>only load and store instructions can access memory</p></blockquote></li></ul></li></ul><h3 id="GPR-Register-Memory-Arch"><a href="#GPR-Register-Memory-Arch" class="headerlink" title="GPR: Register-Memory Arch"></a>GPR: Register-Memory Arch</h3><ul><li>Register-memory architecture(any instruction can access memory)</li><li>C &#x3D; A + B<ul><li>Load R1, A</li><li>Add R3, R1, B</li><li>Store R3, C</li></ul></li></ul><center class="half">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061654274.png" width="200" height="350">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061655127.png" width="200" height="350">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061655935.png" width="200" height="350"></center><h3 id="GPR-Load-Store-Architecture"><a href="#GPR-Load-Store-Architecture" class="headerlink" title="GPR: Load-Store Architecture"></a>GPR: Load-Store Architecture</h3><ul><li>Load-Store Architecture(only load and store instructions can access memory)</li><li>C &#x3D; A + B<ul><li>Load R1, A</li><li>Load R2, B</li><li>Add R3, R1, R2</li><li>Store R3, C</li></ul></li></ul><center class="half">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061658992.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061658304.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061658863.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061659560.png" width="200" height="325">    <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061659503.png" width="200" height="325"></center><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><blockquote><p>$D &#x3D; A \times B - ( A + C \times B)$</p></blockquote><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><blockquote><p>Instruction set: </p><ul><li>add, sub, mul, div, …</li><li>push A, pop A</li></ul></blockquote><ul><li>Answer<ol><li>push A</li><li>push B</li><li>mul</li><li>push A</li><li>push C</li><li>push B</li><li>mul</li><li>add</li><li>sub</li><li>pop D</li></ol></li></ul><h4 id="Accumulator"><a href="#Accumulator" class="headerlink" title="Accumulator"></a>Accumulator</h4><blockquote><p>Instruction set:</p><ul><li>add A, sub A, mult A, div A, …</li><li>load A, store A</li></ul></blockquote><ul><li>Answer:<ol><li>load C</li><li>mult B</li><li>add A</li><li>store D</li><li>load A</li><li>mult B</li><li>sub D</li><li>store D</li></ol></li></ul><h4 id="Memory-Memory"><a href="#Memory-Memory" class="headerlink" title="Memory-Memory"></a>Memory-Memory</h4><blockquote><p>Instruction set:</p><ul><li>3 operands: add A, B, C; sub A, B, C; mul A, B, C</li><li>2 operands:add A, B; sub A, B; mul A, B; mov A, B</li></ul></blockquote><ul><li>Answer:<ul><li>3 operands:<ul><li>mul D, A, B</li><li>mul E, C, B</li><li>add E, A, E</li><li>sub D, D, E</li></ul></li><li>2 operands:<ul><li>mov D, A</li><li>mul D, B</li><li>mov E, C</li><li>mul E, B</li><li>add E, A</li><li>sub D, E</li></ul></li></ul></li></ul><h4 id="Register-Memory"><a href="#Register-Memory" class="headerlink" title="Register-Memory"></a>Register-Memory</h4><blockquote><p>Instruction set:</p><ul><li>add R1, A; sub R1, A; mul R1, B</li><li>load R1, A; store R1, A</li></ul></blockquote><ul><li>Answer:<ul><li>load R1, A</li><li>mul R1, B</li><li>load R2, C</li><li>mul R2, B</li><li>add R2, A</li><li>store R2, D</li><li>sub R1, D</li><li>store R1, D</li></ul></li></ul><h4 id="Load-Store"><a href="#Load-Store" class="headerlink" title="Load-Store"></a>Load-Store</h4><blockquote><p>Instruction set:</p><ul><li>add R1, R2, R3; sub R1, R2, R3; mul R1, R2, R3</li><li>load R1, &amp;A; store R1, &amp;A</li></ul></blockquote><ul><li>Answer:<ul><li>load R1, &amp;A</li><li>load R2, &amp;B</li><li>load R3, &amp;C</li><li>mul R3, R3, R2 &#x2F;&#x2F; R3 &#x3D; B*C</li><li>add R3, R3, R1 &#x2F;&#x2F; R3 &#x3D; A+B*C</li><li>mul R1, R1, R2 &#x2F;&#x2F;R1 &#x3D; A*B</li><li>sub R1, R1, R3 </li><li>store R1, D</li></ul></li></ul><h2 id="RISC-V-ISA"><a href="#RISC-V-ISA" class="headerlink" title="RISC-V ISA"></a>RISC-V ISA</h2><h3 id="Formats-of-Instruction"><a href="#Formats-of-Instruction" class="headerlink" title="Formats of Instruction"></a>Formats of Instruction</h3><blockquote><p>不需要记住具体哪位对应什么，需要记住R型指令是什么，I型是什么……</p></blockquote><h3 id="RISC-V-Address-Mode"><a href="#RISC-V-Address-Mode" class="headerlink" title="RISC-V Address Mode"></a>RISC-V Address Mode</h3><p>四种寻址方式</p><ol><li>立即数寻址 | Immediate addressing</li><li>寄存器寻址 | Register addressing</li><li>基寻址 | Base addressing</li><li>PC-relative addressing</li></ol><h3 id="Register-Operands"><a href="#Register-Operands" class="headerlink" title="Register Operands"></a>Register Operands</h3><ol><li><p>Arithmetic instructions use register operands</p></li><li><p>RISC-V has a 32$\times$32-bit register file</p></li><li><ol><li>Use for frequently accessed data</li><li>Numbered 0 to 31</li><li>32-bit data called a “word”</li></ol></li><li><p>Assemble names</p></li><li><ol><li>x0: constant 0</li><li>x1: link register</li><li>x2: stack pointer</li><li>x3: global pointer</li><li>x4: thread pointer</li><li>x5-x7, x28-x31: temporay</li><li>x8-x9, x18-x27: save</li><li>x10-x17: parameter &#x2F; result</li></ol></li></ol><h3 id="Memory-Operands"><a href="#Memory-Operands" class="headerlink" title="Memory Operands"></a>Memory Operands</h3><ul><li>Main memory used for composite data<ul><li>Arrays, structures, dynamic data</li></ul></li><li>To apply arithmetic operations<ul><li>Load values from memory into register</li><li>Store result from register to memory</li></ul></li><li>Memory is byte addressed<ul><li>Each address identifies an 8-bit byte</li></ul></li><li>Words are aligned in memory<ul><li>Address must be a multiple of 4</li></ul></li><li>RISC-V is Little Endian<ul><li>Least-significant byte at least address</li><li>c.f.Big Endian: most-significant byte at least adddress of a word</li></ul></li></ul><h3 id="Register-vs-Memory"><a href="#Register-vs-Memory" class="headerlink" title="Register vs. Memory"></a>Register vs. Memory</h3><ul><li>Register are faster to access than memory</li><li>Operating on memory data requires loads and stores<ul><li>More instructions to be executed</li></ul></li><li>Compiler must use registers for variables as much as possible<ul><li>Only spill to memory for less frequently used variables</li><li>Register optimization is important</li></ul></li></ul><h2 id="The-Four-ISA-Design-Principles"><a href="#The-Four-ISA-Design-Principles" class="headerlink" title="The Four ISA Design Principles"></a>The Four ISA Design Principles</h2><ol><li>Simplicity favors regularity</li><li>Smaller is faster</li><li>Make the common case fast</li></ol><blockquote><p> 例如x0是硬件0，无法改变</p></blockquote><ol start="4"><li>Good design demands good compromises</li></ol><h1 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h1><h2 id="Different-modes-of-execution"><a href="#Different-modes-of-execution" class="headerlink" title="Different modes of execution"></a>Different modes of execution</h2><ul><li><p>Sequential execution</p><ul><li>Advantages: Simple control, saving equipment.</li></ul></li><li><p>Single&#x2F;Twice overlapping execution</p><ul><li>Advantages: High-usage of functional unit, the utilization rate of functional unit is improved obviously.</li><li>Disadvantages:<ul><li>Much more hardware was needed.</li><li>Single: the control process became complicated.</li><li>Twice: <ul><li>Separate fetch, decode, and execution components are required.</li><li>Conflict in access memory<ul><li>Instruction memory &amp; data memory</li><li>Instruction cache &amp; data cache (same memory): Hardware structure </li><li>Adding instruction buffer between memory and instruction decode unit.</li></ul></li></ul></li></ul></li></ul></li></ul><blockquote><p>顺序执行和重叠执行在时间上的差异和计算</p></blockquote><h2 id="What-is-pipelining"><a href="#What-is-pipelining" class="headerlink" title="What is pipelining?"></a>What is pipelining?</h2><ul><li>Pipelining: 一条指令的进程被分成m(m&gt;2)个时间相同的子进程，且m条相邻指令的进程在同一时间内交错重叠。</li><li>Pipelining可以看作重叠执行(overlapping execution)的扩展；</li><li>流水线中的每个子进程及其功能组件叫做阶段(stages or segments of the pipeling)</li><li>阶段的数量叫做流水线的深度(depth)</li></ul><h2 id="Characteristics-of-pipelining"><a href="#Characteristics-of-pipelining" class="headerlink" title="Characteristics of pipelining"></a>Characteristics of pipelining</h2><ul><li><u>流水线寄存器</u></li><li>适用场景：<ul><li>Pipelining technology is suitable for a large number of repetitive sequential processes. Only when tasks are continuously provided at the input, te efficiency of pipelining can be brought into full play.</li></ul></li><li>The pipelining needs the <u>pass time</u> and the <u>empty time</u><ul><li><u>Pass time</u>: the time for the first task from beginning(entering the pipelining) to ending.</li><li><u>Empty time</u>: the time for the last task entering the pipelining to have the result.</li></ul></li></ul><h2 id="Classes-of-pipelining"><a href="#Classes-of-pipelining" class="headerlink" title="Classes of pipelining"></a>Classes of pipelining</h2><ul><li>第一类分类方式：<ul><li><u>Single function pipelining | 单功能</u>: only one fixed function pipelining.<ul><li><u>Multi function pipelining | 多功能</u>: each section of the pipelining can be connected differently for several different functions.<ul><li><u>Static pipelining</u>: 静态在同一的时间段内，只能按同一功能连接（如：必须先把加法做完，才可以做乘法）<ul><li>For static pipelining, only the input is a series of teh same operation tasks, the efficiency of pipelining can be brought into full play.</li></ul></li><li><u>Dynamic pipelining</u>: 动态在同一时间段内，不同功能可以连接（如：在做加法的时候可以插入乘法）</li></ul></li></ul></li></ul></li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052228662.png" alt="img"></p><ul><li>第二类分类方式：<ul><li><u>Component level pipelining(in component-operation pipelining</u>:</li><li><u>Processor level pipelining(inter component-instructino pipelining)</u>:</li><li>Inter processor pipelining(inter processor-macro pipelining):</li></ul></li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052228847.png" alt="img"></p><ul><li><p>第三类分类方式：线性和非线性</p><ul><li><p><u>Linear pipelinin</u></p></li><li><p><u>Nonlinear pipelining</u></p><ul><li>存在一种基于表的调度，满足一定顺序才能实现某种功能</li></ul><blockquote><p>非线性流水线调度问题</p></blockquote><ul><li><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052230432.png" alt="img"></li></ul></li></ul></li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052229786.png" alt="img"></p><ul><li>第四类分类<ul><li><u>Ordered pipelining</u></li><li><u>Disordered pipelining</u></li></ul></li></ul><blockquote></blockquote><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052231089.png" alt="img"></p><ul><li>第五类分类<ul><li><u>Scalar processor</u></li><li><u>Vector pipelining processor</u></li></ul></li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052232465.png" alt="img"></p><h2 id="Pipeline-Performance"><a href="#Pipeline-Performance" class="headerlink" title="Pipeline Performance"></a>Pipeline Performance</h2><h3 id="Throughput-TP-吞吐量"><a href="#Throughput-TP-吞吐量" class="headerlink" title="Throughput(TP) | 吞吐量"></a>Throughput(TP) | 吞吐量</h3><h3 id="Speedup-SP-加速比"><a href="#Speedup-SP-加速比" class="headerlink" title="Speedup(SP) | 加速比"></a>Speedup(SP) | 加速比</h3><h3 id="Efficiency-eta-效率"><a href="#Efficiency-eta-效率" class="headerlink" title="Efficiency($\eta$) | 效率"></a>Efficiency($\eta$) | 效率</h3><h2 id="RISC-V-Pipelining"><a href="#RISC-V-Pipelining" class="headerlink" title="RISC-V Pipelining"></a>RISC-V Pipelining</h2><ul><li>Five stages, one step per stage</li></ul><ol><li>IF: 取指，取出 I-Mem 中 PC 地址处的指令</li><li>ID: 译码，将指令解码为控制信号，并读取寄存器值</li><li>EX: 执行，执行 ALU 操作</li><li>MEM: 访存，访问 D-Mem 进行写入或读取</li><li>WB: 写回，将结果写回寄存器文件</li></ol><h3 id="Pipelining-and-ISA-Design"><a href="#Pipelining-and-ISA-Design" class="headerlink" title="Pipelining and ISA Design"></a>Pipelining and ISA Design</h3><ul><li><p>RISC-V ISA designed for pipelining</p><ul><li><p>指令长度固定为 32 位，易于在一个周期内进行取指或译码</p></li><li><p>指令格式少且规整，易于在一个周期内译码、读取寄存器</p></li><li><p>使用 load&#x2F;store 寻址结构，一个周期计算地址、一个周期访存</p></li><li><p>访存操作都是对齐的，可以在一个周期内进行</p></li></ul></li></ul><h3 id="An-Implementation-of-Pipelining"><a href="#An-Implementation-of-Pipelining" class="headerlink" title="An Implementation of Pipelining"></a>An Implementation of Pipelining</h3><ul><li>添加阶段寄存器（pipeline register）来分隔每个阶段：IF&#x2F;ID、ID&#x2F;EX、EX&#x2F;MEM、MEM&#x2F;WB<ul><li>这四个阶段寄存器和 PC 寄存器一起将流水线分为了五个部分</li><li>可以<strong>看作</strong>只有这五个时序电路，其它内部操作都是组合逻辑，在内部运行</li><li>五个寄存器在上升沿进行更新，阶段寄存器进行流转，记录当前指令需要的信息</li></ul></li><li>数据通路中有两个回路<ul><li>MEM 阶段计算分支结果，输出给 PC。可能会引起控制冒险</li><li>WB 阶段写回寄存器，可能会引起数据冒险</li></ul></li><li>ID 和 WB 阶段同时使用寄存器组文件，但不会产生结构冒险，因为 ID 阶段只读取寄存器，WB 阶段只写入寄存器，相当于分为了两个部分</li></ul><h2 id="How-Pipelining-Improves-Performance"><a href="#How-Pipelining-Improves-Performance" class="headerlink" title="How Pipelining Improves Performance"></a>How Pipelining Improves Performance</h2><ul><li>Decreasing the execution time of an individual instruction:heavy_multiplication_x:</li><li>Increasing instruction throughput     :heavy_check_mark:</li></ul><h3 id="The-Pipelined-Version-of-the-Datapath"><a href="#The-Pipelined-Version-of-the-Datapath" class="headerlink" title="The Pipelined Version of the Datapath"></a>The Pipelined Version of the Datapath</h3><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052323066.png" alt="image-20230105232315849"></p><ul><li>几种呈现方式：</li></ul><blockquote><p>了解即可，考试不会要求绘画</p></blockquote><ul><li>Multiple-Clock-Cycle Pipeline Diagram of five Instructions</li></ul><p>​<img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052324443.png" alt="image-20230105232423375"></p><ul><li>Traditional Multiple-Clock-Cycle Pipeline Diagram</li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052326835.png" alt="image-20230105232653764"></p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301052327819.png" alt="image-20230105232705734"></p><h2 id="Pipeline-Hazards"><a href="#Pipeline-Hazards" class="headerlink" title="Pipeline Hazards"></a>Pipeline Hazards</h2><ul><li><p>Structural Hazard</p><ul><li><p>A required resource is busy</p></li><li><p>Solution:</p><ol><li>Instructions take it in turns use resource, some instruction have to stall</li><li>Add more hardware to machine</li></ol><blockquote><p>Can always solve by adding more hardware</p></blockquote></li></ul></li><li><p>Data Hazards</p><ul><li><p>Data dependency between instructions</p></li><li><p>Need to wait for previous instruction to complete its data read&#x2F;write</p></li><li><p>Solution:</p><ul><li><p><u>Forwarding | 前递</u>: Adding extra hardware to retrieve the missing item early from the internall resources</p><ul><li>Forwarding Conditions:</li></ul><p></p><table><thead><tr><th>Mux Control</th><th>Source</th><th>Explanation</th></tr></thead><tbody><tr><td>ForwardA &#x3D; 00</td><td>ID&#x2F;EX</td><td>The first ALU operand comes from the register</td></tr><tr><td>FA &#x3D; 10</td><td>EX&#x2F;MEM</td><td>~ comes from the prior ALU result</td></tr><tr><td>FA &#x3D; 01</td><td>MEM&#x2F;WB</td><td>~ comes from data memory or an earlier ALU result</td></tr><tr><td>FB &#x3D; 00</td><td>ID&#x2F;EX</td><td>The second ALU operand ~</td></tr><tr><td>FB &#x3D; 10</td><td>EX&#x2F;MEM</td><td>~ ~</td></tr><tr><td>FB &#x3D; 01</td><td>MEM&#x2F;WB</td><td>~ ~</td></tr></tbody></table></li><li><p><u>Stall | 暂停</u>: </p><ul><li>对于 Load-Use Data Hazard<ul><li>在 ID 阶段就进行探测 load-use 冒险<ul><li>ID&#x2F;EX.MemRead &#x3D;&#x3D; 1 (ID&#x2F;EX.MemWrite &#x3D;&#x3D; 0)</li><li>ID&#x2F;EX.Rd &#x3D;&#x3D; IF&#x2F;ID.Rs1 或 IF&#x2F;ID.Rs2</li></ul></li><li>暂停流水线：<ul><li>强制 ID&#x2F;EX 阶段寄存器中的控制信号变为 0（相当于插入一条 nop）</li><li>阻止 PC 寄存器和 IF&#x2F;ID 阶段寄存器更新</li></ul></li><li>在暂停一个周期后就可以按照 MEM hazard 进行前递解决</li></ul></li></ul></li><li><p>DataPath with Hazard Detection</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061046617.png" alt="image-20230106104626574"></p></li></ul></li></ul></li><li><p>Control Hazards</p><ul><li>Flow of execution depends on previous instruction</li><li>Branch determines flow of control<ul><li>Fetching next instruction depends on branch outcome</li><li>Pipelining can’t always fetch correct instruction<ul><li>Still working on ID stage of branch</li></ul></li></ul></li><li>In RISC-V pipelining<ul><li>Need to <u>compare registers</u> and <u>compute target</u> early in the pipelining</li><li>Add hardware to do it in ID stage</li></ul></li><li>How to Reduce Branch Delay<ul><li>Key processes in branch instructions<ul><li>Compute the branch target address</li><li>Judge if the branch success</li></ul></li><li>Move hardware to determine outcome to ID stage<ul><li>Target adddress adder</li><li>Register comparator</li></ul></li></ul></li></ul></li></ul><h3 id="Code-Scheduling"><a href="#Code-Scheduling" class="headerlink" title="Code Scheduling"></a>Code Scheduling</h3><blockquote><p>分支延迟槽，来避免一些冲突(MIPs常使用)</p></blockquote><ul><li><p>Scheduling from former</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061120227.png" alt="image-20230106112002200"></p></li><li><p>Scheduling from object</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061120850.png" alt="image-20230106112015814"></p></li><li><p>Scheduling from failure</p></li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061120242.png" alt="image-20230106112031206"></p><h3 id="Data-Hazards-for-Branches"><a href="#Data-Hazards-for-Branches" class="headerlink" title="Data Hazards for Branches"></a>Data Hazards for Branches</h3><ul><li><p>If a comparsion register is destination of 2^nd^ or 3^rd^ preceding ALU instruction</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061128286.png" alt="image-20230106112850251"></p><ul><li>Can resolve using forwarding</li></ul></li><li><p>If a comparsion register is a destination of preceding ALU instruction or 2^nd^ preceding load instruction</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061129264.png" alt="image-20230106112902225"></p><ul><li>Need 1 stall cycle</li></ul></li><li><p>If a comparsion register is a destination of immediately preceding load instruction</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061129399.png" alt="image-20230106112912360"></p><ul><li>Need 2 stall cycles</li></ul></li></ul><h3 id="Dynamic-Branch-Prediction"><a href="#Dynamic-Branch-Prediction" class="headerlink" title="Dynamic Branch Prediction"></a>Dynamic Branch Prediction</h3><ul><li><p>In deeper and superscalar pipelines, branch penalty is more significant</p></li><li><p>Use dynamic prediction</p><ul><li><p>Branch prediction buffer (aka branch history table | 分支历史表)</p></li><li><p>Indexed by recent branch instruction addresses | 表头是最近的分支指令的地址</p></li><li><p>Stores outcome (taken&#x2F;not taken) | 表的内容是是否跳转</p></li><li><p>To execute a branch</p><ul><li><p>Check table, expect the same outcome</p></li><li><p>Start fetching from fall-through or target</p></li><li><p>If wrong, flush pipeline and flip prediction</p></li></ul></li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061135780.png" alt="image-20230106113510751"></p></li></ul><h4 id="1-Bit-Predictor-Shortcoming"><a href="#1-Bit-Predictor-Shortcoming" class="headerlink" title="1-Bit Predictor: Shortcoming"></a>1-Bit Predictor: Shortcoming</h4><ul><li><p>Inner loop branches mispredicted twice! | 内循环结束和再次进入的时候有两个误预判</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061136163.png" alt="image-20230106113619139"></p><ul><li><p>Mispredict as taken on last iteration of inner loop</p></li><li><p>Then mispredict as not taken on first iteration of inner loop next time around</p><blockquote><p>为解决这个问题，引入两位的预测器</p></blockquote></li></ul></li></ul><h4 id="2-Bit-Predictor"><a href="#2-Bit-Predictor" class="headerlink" title="2-Bit Predictor"></a>2-Bit Predictor</h4><ul><li><p>Only change prediction on two successive mispredictions</p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061139665.png" alt="image-20230106113949627"></p></li></ul><blockquote><p>有限状态机</p></blockquote><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061145267.png" alt="image-20230106114527240"></p><h2 id="Instruction-Level-Parallelism-ILP"><a href="#Instruction-Level-Parallelism-ILP" class="headerlink" title="Instruction-Level Parallelism(ILP)"></a>Instruction-Level Parallelism(ILP)</h2><blockquote><p>多发射,在一个时钟周期发射多条指令，同步执行</p></blockquote><ul><li>Pipelining: executing multiple instructions in parallel</li><li>To increase ILP<ul><li>Deeper pipeline<ul><li>Less work per stage -&gt; shorter clock cycle</li></ul></li><li>Multiple issue<ul><li>Replicate pipeline stages -&gt; multiple pipelines</li><li>Start multiple instructions per clock cycle</li><li>CPI &lt; 1, so use Instructions Per Cycle(IPC)</li><li>E.g., 4GHz 4-way multiple-issue<ul><li>16 BIPS, peak CPI &#x3D; 0.25, peak IPC &#x3D; 4</li></ul></li><li>But dependencies reduce this in pratice</li></ul></li></ul></li></ul><h2 id="Multiple-Issus"><a href="#Multiple-Issus" class="headerlink" title="Multiple Issus"></a>Multiple Issus</h2><ul><li><p>Static multiple issue | 静态多发射</p><blockquote><p>由软件（编译器）决定哪些指令发射出去</p></blockquote><ul><li>Compiler groups instructions to be issued together</li><li>Packages them into “issue slots（发射槽）”</li><li>Compiler detects and avoids hazards</li></ul></li><li><p>Dynamic multiple issue</p><ul><li>CPU examines instruction stream and chooses instructions to issue each cycle</li><li>Compiler can help by recordering instructions</li><li>CPU resolves hazards suing advanced techniques at run time</li></ul></li></ul><h3 id="Two-types-of-multiple-issue-processor"><a href="#Two-types-of-multiple-issue-processor" class="headerlink" title="Two types of multiple-issue processor"></a>Two types of multiple-issue processor</h3><ul><li>和多发射基本相同，但每次发射的条数是不固定的</li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061242167.png" alt="image-20230106124205123"></p><ul><li>超长指令字 | 静多发射——定发射条数，由CPU管理</li></ul><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061242352.png" alt="image-20230106124240304"></p><h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p> <img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061329959.png" alt="image-20230106132928922"></p><h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><h3 id="Static-Multiple-Issue"><a href="#Static-Multiple-Issue" class="headerlink" title="Static Multiple Issue"></a>Static Multiple Issue</h3><ul><li>Compiler must remove some&#x2F;all hazards<ul><li>Recorder instructions inti issue packeys</li><li>No dependencies with a packet</li><li>Possibly some dependecies between packets<ul><li>Varies between ISAs; compiler must konw!</li></ul></li><li>Pad with nop if necessary</li></ul></li></ul><h3 id="Dynamic-Multiple-Issue"><a href="#Dynamic-Multiple-Issue" class="headerlink" title="Dynamic Multiple Issue"></a>Dynamic Multiple Issue</h3><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061332877.png" alt="image-20230106133217838"></p><blockquote><p><u>一些性质</u></p></blockquote><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061332809.png" alt="image-20230106133247771"></p><p><img src="https://gitee.com/enl-z/typora_-images/raw/master/202301061333518.png" alt="image-20230106133352475"></p>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> 大二秋冬 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构基础 | FDS</title>
      <link href="/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%20_%20FDS/"/>
      <url>/2022/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%20_%20FDS/</url>
      
        <content type="html"><![CDATA[<p><a name="E9EBH"></a></p><h3 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h3><ul><li>💻<a href="https://www.yuque.com/2002_08_12/ctdxva/rqc25x">算法分析和抽象数据类型</a></li></ul><p><a name="adahc"></a></p><h3 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h3><ul><li>💻<a href="https://www.yuque.com/2002_08_12/ctdxva/dx286d7dw27lenvm">线性结构</a></li></ul><hr><blockquote><p>持续更新ing~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> 大二秋冬 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大一下</title>
      <link href="/2022/08/02/%E5%A4%A7%E4%B8%80%E4%B8%8B/"/>
      <url>/2022/08/02/%E5%A4%A7%E4%B8%80%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="中国近代史纲要"><a href="#中国近代史纲要" class="headerlink" title="中国近代史纲要"></a>中国近代史纲要</h1><p>zh老师讲的真的很好，可惜我听的次数不多😓。<br>真诚劝大噶好好完成小组作业，对自己负责也是对小组负责；<br>期末只浅浅地把课本翻了一遍（把每章有什么内容熟悉一下）就上考场了，成绩还行；<br>一句话“zh老师真的超级好！！！”</p><hr><h1 id="体适能"><a href="#体适能" class="headerlink" title="体适能"></a>体适能</h1><h2 id="课程简介：可以理解为体能，课程内容就是静态拉伸-动态拉伸-体能训练or身体协调-x2F-平衡性练习……"><a href="#课程简介：可以理解为体能，课程内容就是静态拉伸-动态拉伸-体能训练or身体协调-x2F-平衡性练习……" class="headerlink" title="课程简介：可以理解为体能，课程内容就是静态拉伸+动态拉伸+体能训练or身体协调&#x2F;平衡性练习……"></a>课程简介：可以理解为体能，课程内容就是静态拉伸+动态拉伸+体能训练or身体协调&#x2F;平衡性练习……</h2><p>早八的体适能有时候蛮顶的（自己跑or走七圈）；<br>zcx老师真的超级温柔😍，会教你无器械的热身和训练动作，而且幸运的话你可以在体适能课程上体验其他课程的内容（比如体验定向越野，看着定向越野的uu们在校园奔跑，而我们慢慢悠悠地走；</p><blockquote><p>划重点:体适能的考核是4 * 10米折返跑，想要拿满分挺难的（我的课上只有一名女生拿了满分），不过如果你可以把其他项搞一下还是可以满绩的。</p></blockquote><hr><h1 id="形势与政策Ⅰ"><a href="#形势与政策Ⅰ" class="headerlink" title="形势与政策Ⅰ"></a>形势与政策Ⅰ</h1><p>这门课就不多说了，期末几乎全靠党性觉悟（懂得都懂😎）</p><hr><h1 id="大学物理（乙）Ⅰ"><a href="#大学物理（乙）Ⅰ" class="headerlink" title="大学物理（乙）Ⅰ"></a>大学物理（乙）Ⅰ</h1><p>这学期最后悔没有好好学的一门课。<br>在期中考试之前，觉得内容很简单便懈怠了，每周只有写作业的时候才去看书学导致期中考试和其前的小测都十分拉跨；<br>期中之后醒悟过来开始好好听课学，虽然后面的小测和期末都考得好但是还是补不回来（因为大家都考的很好</p><hr><h1 id="信息安全原理与数学基础"><a href="#信息安全原理与数学基础" class="headerlink" title="信息安全原理与数学基础"></a>信息安全原理与数学基础</h1><h2 id="课程简介：这门课可以说是离散数学和概率论合在一起了-，不过相对于单独的离散和概率论课程，信安原理与数学基础教的内容要浅且考试难度低"><a href="#课程简介：这门课可以说是离散数学和概率论合在一起了-，不过相对于单独的离散和概率论课程，信安原理与数学基础教的内容要浅且考试难度低" class="headerlink" title="课程简介：这门课可以说是离散数学和概率论合在一起了 ，不过相对于单独的离散和概率论课程，信安原理与数学基础教的内容要浅且考试难度低"></a>课程简介：这门课可以说是离散数学和概率论合在一起了 ，不过相对于单独的离散和概率论课程，信安原理与数学基础教的内容要浅且考试难度低</h2><p>私以为zbs和qz老师都教的超级好。<br>对zbs老师一整个爱住，他可以用超通俗的语言让你学会离散；<br>而对qz老师，我很喜欢他教课的节奏。<br>总结下来：平时的积累很重要，只要你把平时教的内容记住了（知道哪个知识点是什么），即便你不精通你也可以拿满绩（苯人离满绩远着呢——六小时速成离散+概率论失败的教训）</p><hr><h1 id="大学英语Ⅳ"><a href="#大学英语Ⅳ" class="headerlink" title="大学英语Ⅳ"></a>大学英语Ⅳ</h1><p>有一说一，xhh老师很负责，如果你真的想提升自己的水平可以去冲。<br>但是从我的角度来说，平时作业有点太多了（它有着这个学分不该有的作业量）😶。</p><hr><h1 id="微积分（甲）Ⅱ"><a href="#微积分（甲）Ⅱ" class="headerlink" title="微积分（甲）Ⅱ"></a>微积分（甲）Ⅱ</h1><p>bwh老师是真的超级负责——上课ipad手写+课后把笔记发到钉钉+各种提醒；<br>如果你喜欢讲课详细的老师，bwh老师绝对是首选；<br>可惜我在这门课上付出的精力不是特别多，期中之前我还会认真听课、写作业。but期中之后，迫于其他课程作业的逼迫+我的效率低，我开始只看她的讲稿了。期末的时候也没能腾出时间完整地复习一遍……</p><blockquote><p>忠告：微（甲）Ⅰ你还能靠期末补天补回来，微（甲）Ⅱ最好平常还是认真刷一些题的好，把定义都能清楚</p></blockquote><hr><h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><p>深深被小白的技术折服（他漫不经心的凡尔赛我真的爱了）<br>虽然是刚好没挂、绩点最拉跨的一门专业课，但是（抛去期末不谈）我觉得是我这学年上的最有意思的课；<br>那为什么最后的绩点那么拉跨呢？<br>本人太过摆烂，好多汇编指令和知识并没有熟悉掌握，每次做作业基本还得再复习一遍（汇编的作业还是蛮有意思的）。期末复习的时候就是说没有复习全面导致好多好多题在同一个指令上卡壳。</p><hr><h1 id="程序设计专题"><a href="#程序设计专题" class="headerlink" title="程序设计专题"></a>程序设计专题</h1><p>相对于C小，这门课进步蛮大的（也算是开始对编程有了些许开窍的感觉）。<br>在这门课上花费的时间还是蛮多的，尤其大作业占去我好多天的时间，主要前后换了三种思路，换一次重新写一次。真正把思路定下来到初步写完时间就不是特别长了，唯一的遗憾就是游戏粗糙了一点（本来准备先提交，等之后再把我想加的功能写一下，然后就没有然后了……😂</p><hr><h1 id="计算机系统Ⅰ"><a href="#计算机系统Ⅰ" class="headerlink" title="计算机系统Ⅰ"></a>计算机系统Ⅰ</h1><h2 id="课程简介：本门课有计算机系统Ⅰ-x2F-Ⅱ-x2F-Ⅲ是这两年信息安全专业新开的课程，包含计算机逻辑设计基础和计算机组成与设计的部分内容"><a href="#课程简介：本门课有计算机系统Ⅰ-x2F-Ⅱ-x2F-Ⅲ是这两年信息安全专业新开的课程，包含计算机逻辑设计基础和计算机组成与设计的部分内容" class="headerlink" title="课程简介：本门课有计算机系统Ⅰ&#x2F;Ⅱ&#x2F;Ⅲ是这两年信息安全专业新开的课程，包含计算机逻辑设计基础和计算机组成与设计的部分内容"></a>课程简介：本门课有计算机系统Ⅰ&#x2F;Ⅱ&#x2F;Ⅲ是这两年信息安全专业新开的课程，包含计算机逻辑设计基础和计算机组成与设计的部分内容</h2><p>这门课有很多想说的：</p><ul><li><p>相对别的课程，我在这门课上投入是最多的，同时收获也是最多的（好多奇奇怪怪的东西都是在做作业的时候学的）；</p></li><li><p>印象最深的例子：因为酷爱作死，把window上安装好的docker玩坏了，然后灰溜溜地去查baidu,各种尝试失败我一气之下把安装的Ubuntu卸了然后准备重新装，但是谁曾想要把所有文件完全清除再次安装后才能正常使用。电脑小白的我开始翻文件、删文件、翻文件、删文件……后来我突然成功了，可以正常使用了。</p></li><li><p>这个时候，让我无语的事情出现了，我汇编用的VMware虚拟机用不了了。然后又是一通搜索，终于我选择把系统升级一下。把win10升到win11后，十分开心，我的VMware虚拟机可以用了（我至今也不理解为什么就能用了）。but无语的事情再次出现，docker又用不了了（当时我真想把电脑砸了），然后实验课的时候我去问TA，他竟这么说“那确实出现了一些错误，用不了了，你自己建个虚拟机在虚拟机里面配一个docker吧”（我真的栓Q）。<br>幸好我在网上找到了教程，我就开始在VMware里面新建一个镜像、配docker。在我的摸索下，终于成功了&#x2F;(ㄒoㄒ)&#x2F;~~</p><blockquote><p>上述例子告诉我们，作死是好事，你可以学到很多知识。同时也告诉我们作死要分时间，如果再给我一次机会，我绝不会在快到ddl的时候拿自己做作业用的家伙什儿作死。</p></blockquote></li><li><p>做完最后的单周期CPU还是有一些感悟的——虽然我很菜，但是静下心来仔细想想还是能把作业做好的。期待Ⅱ&#x2F;Ⅲ  &amp; 希望别再摆烂。</p></li></ul><hr><h1 id="一些反思-amp-总结"><a href="#一些反思-amp-总结" class="headerlink" title="一些反思&amp;总结"></a>一些反思&amp;总结</h1><ol><li>这学年与其说投入学习的时间很多很多，不如说投入作业的时间很多很多。最大的问题在于效率太低了，我自己都能感觉到的低。可能还是没有从大一上那种比较悠闲的节奏上转变过来（或者说是内心不想接受这个事实而自欺欺人，想着躺平）；</li><li>除学业外的工作做的还说的过去——虽然有一些活动我没有参加，但是参加的都尽力了；</li></ol><h2 id="一些flag"><a href="#一些flag" class="headerlink" title="一些flag"></a>一些flag</h2><ol><li>希望把自己的效率提起来、少拖沓，省出时间去做想做的事情；</li><li>不得过且过、自欺欺人，用心去掌握知识；</li><li>把我这难看的GPA提一提。</li></ol><blockquote><p>相关学习资料链接会在很久很久很久之后发出来😥</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Memory </category>
          
          <category> 大一春夏 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么决定做这个网页</title>
      <link href="/2022/08/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E5%81%9A%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5/"/>
      <url>/2022/08/02/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E5%81%9A%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>为了学习 ❌<br>为了装* ✔️</p><hr><p>💬过了2022年9月7日，我就加入奔三人群大军了😔，有必要给自己短暂的青春留下一点记录了；<br>💬经过一年的ZJU生活，有一些想说的话（老人的劝告心理😥<br>💬（主要原因）看着自己难看的GPA开始深深反思自己的躺平大一，并且发现这么下去我将难以实现我的目标。内心的羞耻和惭愧让我决定做一个网页来记录我的总结和一些些反思（maybe对别人有一丢丢参考价值👀</p><blockquote><p>不建议打赏（但如果你非常愿意打赏，我也没有办法拒绝👀</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
